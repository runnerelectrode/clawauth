/**
 * clawauth — OpenClaw Gateway Plugin
 *
 * Gives every agent a verifiable Web Bot Auth identity (RFC 9421 / Ed25519).
 * Registers a `signed_fetch` tool that signs outbound HTTP requests with
 * the agent's Ed25519 key before sending.
 *
 * Each agent's workspace should contain:
 *   clawauth/key.json    — Ed25519 keypair (generated by `clawauth keygen`)
 *   clawauth/config.json — agent_id, username, jwksUrl (from `clawauth register`)
 *
 * The tool factory receives the agent's workspaceDir, loads the key,
 * and creates a per-agent signed_fetch tool that closes over the key.
 *
 * Installation:
 *   1. Place (or symlink) this directory in ~/.openclaw/extensions/clawauth/
 *   2. Enable in openclaw.json:  plugins.entries.clawauth.enabled = true
 *   3. Add "signed_fetch" to tools.sandbox.tools.allow (if using sandbox tool lists)
 *   4. Restart the gateway
 */

import { createPrivateKey, sign as cryptoSign, randomUUID } from "node:crypto";
import { readFileSync, existsSync } from "node:fs";
import { join } from "node:path";

// ── Key Loading ──────────────────────────────────────────────────────────────

function loadAgentKey(workspaceDir) {
  const keyFile = join(workspaceDir, "clawauth", "key.json");
  const configFile = join(workspaceDir, "clawauth", "config.json");

  if (!existsSync(keyFile)) return null;

  try {
    const key = JSON.parse(readFileSync(keyFile, "utf-8"));
    let jwksUrl = null;
    if (existsSync(configFile)) {
      const config = JSON.parse(readFileSync(configFile, "utf-8"));
      jwksUrl = config.jwksUrl || null;
    }
    return {
      kid: key.kid,
      privateKey: createPrivateKey(key.privateKeyPem),
      jwksUrl,
    };
  } catch {
    return null;
  }
}

// ── RFC 9421 Signing ─────────────────────────────────────────────────────────

function signRequest(method, url, agent) {
  const parsed = new URL(url);
  const authority = parsed.host;
  const path = parsed.pathname + parsed.search;

  const created = Math.floor(Date.now() / 1000);
  const expires = created + 300;
  const nonce = randomUUID();

  const lines = [
    `"@method": ${method.toUpperCase()}`,
    `"@authority": ${authority}`,
    `"@path": ${path || "/"}`,
  ];

  const sigInput =
    `("@method" "@authority" "@path")` +
    `;created=${created}` +
    `;expires=${expires}` +
    `;nonce="${nonce}"` +
    `;keyid="${agent.kid}"` +
    `;alg="ed25519"`;

  lines.push(`"@signature-params": ${sigInput}`);

  const base = lines.join("\n");
  const sig = cryptoSign(null, Buffer.from(base), agent.privateKey).toString(
    "base64",
  );

  const headers = {
    Signature: `sig1=:${sig}:`,
    "Signature-Input": `sig1=${sigInput}`,
  };

  if (agent.jwksUrl) {
    headers["Signature-Agent"] = agent.jwksUrl;
  }

  return headers;
}

// ── Plugin ───────────────────────────────────────────────────────────────────

export default function register(api) {
  const agentKeys = new Map();

  // Register a signed_fetch tool per agent via tool factory.
  // The factory is called once per agent session with the agent's context,
  // so each agent gets a tool that closes over its own signing key.
  api.registerTool((ctx) => {
    if (!ctx.workspaceDir) return null;

    // Load and cache key for this agent
    let agent = agentKeys.get(ctx.agentId);
    if (agent === undefined) {
      agent = loadAgentKey(ctx.workspaceDir);
      agentKeys.set(ctx.agentId, agent);
      if (agent) {
        api.logger.info(
          `[clawauth] ${ctx.agentId}: loaded key kid=${agent.kid}`,
        );
      }
    }
    if (!agent) return null;

    return {
      label: "Signed Fetch",
      name: "signed_fetch",
      description:
        "Fetch a URL with WBA identity signatures (RFC 9421 / Ed25519). " +
        "Use this instead of web_fetch when the target site supports " +
        "Web Bot Auth verification, or to present a verifiable agent identity.",
      parameters: {
        type: "object",
        properties: {
          url: {
            type: "string",
            description: "The URL to fetch (http or https)",
          },
          method: {
            type: "string",
            enum: ["GET", "HEAD"],
            description: "HTTP method (default: GET)",
          },
          maxChars: {
            type: "number",
            description: "Maximum characters to return (default: 50000)",
          },
        },
        required: ["url"],
      },
      execute: async (_toolCallId, params) => {
        const url = String(params.url || "");
        const method = String(params.method || "GET").toUpperCase();
        const maxChars = Number(params.maxChars) || 50000;

        // Validate URL
        let parsed;
        try {
          parsed = new URL(url);
        } catch {
          return {
            content: [{ type: "text", text: "Error: Invalid URL" }],
            isError: true,
          };
        }

        if (!["http:", "https:"].includes(parsed.protocol)) {
          return {
            content: [
              { type: "text", text: "Error: URL must be http or https" },
            ],
            isError: true,
          };
        }

        // Sign the request
        const sigHeaders = signRequest(method, url, agent);

        api.logger.info(
          `[clawauth] ${ctx.agentId}: ${method} ${parsed.host}${parsed.pathname} signed kid=${agent.kid}`,
        );

        try {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 30_000);

          const response = await fetch(url, {
            method,
            headers: {
              Accept: "text/markdown, text/html;q=0.9, */*;q=0.1",
              "User-Agent": "OpenClaw/1.0 (clawauth-signed)",
              "Accept-Language": "en-US,en;q=0.9",
              ...sigHeaders,
            },
            redirect: "follow",
            signal: controller.signal,
          });

          clearTimeout(timeout);

          const contentType = response.headers.get("content-type") || "";
          let body = await response.text();

          if (body.length > maxChars) {
            body =
              body.slice(0, maxChars) +
              "\n\n[Truncated after " +
              maxChars +
              " characters]";
          }

          const result = {
            url,
            status: response.status,
            contentType: contentType.split(";")[0].trim(),
            signed: true,
            kid: agent.kid,
            content: body,
          };

          return {
            content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
          };
        } catch (err) {
          return {
            content: [
              {
                type: "text",
                text: `Error fetching ${url}: ${err.message}`,
              },
            ],
            isError: true,
          };
        }
      },
    };
  });

  // Log whenever unsigned web_fetch is used by an agent that has a signing key
  api.on("after_tool_call", (event, ctx) => {
    if (event.toolName === "web_fetch" && agentKeys.get(ctx.agentId)) {
      api.logger.info(
        `[clawauth] ${ctx.agentId}: web_fetch used (unsigned) — signed_fetch available`,
      );
    }
  });

  api.logger.info("[clawauth] plugin registered");
}
